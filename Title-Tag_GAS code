/***** CONFIG *****/
const ROOT_FOLDER_ID = "1F_Byvx8MzyhFDqcZxbD4pyqunw4oy7nn";
const PROCESS_FOLDER_NAME = "処理";
const DONE_FOLDER_NAME = "完了";
const ERROR_FOLDER_NAME = "失敗"; // optional

// ===== JP fallback tags (only used when tags are <49 after sanitize/uniq) =====
const JP_FALLBACK_TAG_POOL = [
  "写真","素材","背景","余白","コピースペース","テクスチャ","パターン","模様","自然","屋外",
  "晴天","青空","夕焼け","黄昏","シルエット","山","森","林","竹林","木道",
  "小道","遊歩道","公園","庭園","花","桜","菜の花","植物","緑","草木",
  "枝","つぼみ","和傘","石灯籠","布","刺繍","格子柄","電車","列車","街並み",
  "建物","時計塔","海","砂浜","作業船","クレーン","春","季節","旅行","観光"
];

// ✅ precision priority
const OPENAI_MODEL = "gpt-4o";

// Safety controls
const MAX_PER_RUN = 6;          // process up to N images per execution
// 320000(約5:20) → 280000(約4:40) 推奨
const SAFE_STOP_MS = 280000; // 4分40秒くらい

// Japanese title ban list（主観/感情/演出＋冗長語）
const JP_TITLE_BANNED_WORDS = [
  "美しい","綺麗","きれい","感動","感動的","仕上げた","仕上がり","素敵","魅力","エモい","かわいい","可愛い",
  "最高","最適","印象的","ドラマチック","幻想的","優雅","エレガント","ロマンチック","おしゃれ","オシャレ",
  "心","気持ち","癒し","映える","映し出す","楽しむ","感じる",
  "風景" // ✅ avoid generic filler
];

const EN_LETTER_RE = /[A-Za-z]/;



// ===== Title anti-bias controls (JP) =====
const TITLE_HISTORY_KEY = "TITLE_HISTORY_JP";
const TITLE_HISTORY_MAX = 120;          // 直近N件を保持（シート削除運用でも効く）
const TITLE_SIM_THRESHOLD = 0.55;       // 類似度が高いほど減点
const JP_TITLE_CANDIDATES = 5;          // 候補数（固定5）

// “偏りやすい定型句”は「禁止」ではなく軽く減点（自由度を保つ）
const JP_TITLE_OVERUSED_PHRASES = [
  "青空の下","背景","景観","光景","眺め","一面","広がる","見える","染まる"
];

/***** SPREADSHEET MENU *****/
function onOpen(e) {
  SpreadsheetApp.getUi()
    .createMenu("画像処理")
    .addItem("処理を実行（タイトル＆タグ生成）", "menu_runPipeline")
    .addSeparator()
    .addItem("処理フォルダの残り枚数を表示", "menu_showRemainingCount")
    .addItem("失敗ログを開く", "menu_openFailLog")
    .addSeparator()
    .addItem("実行状態をリセット（RunState削除）", "menu_clearRunState")
    .addToUi();
}

function menu_runPipeline() {
  const ui = SpreadsheetApp.getUi();
  try {
    const summary = runPipelineWithSummary_();
    SpreadsheetApp.getActive().toast(summary, "画像処理", 8);
    ui.alert(summary);
  } catch (e) {
    const msg = "実行中にエラーが発生しました。\n\n" + String(e);
    SpreadsheetApp.getActive().toast(msg, "画像処理（エラー）", 10);
    ui.alert(msg);
    throw e; // Executionsにも残す
  }
}

function menu_showRemainingCount() {
  const root = DriveApp.getFolderById(ROOT_FOLDER_ID);
  const processFolder = getOrCreateChildFolder_(root, PROCESS_FOLDER_NAME);

  let total = 0, imageCount = 0, nonImageCount = 0;
  const files = processFolder.getFiles();
  while (files.hasNext()) {
    const f = files.next();
    total++;
    const mime = f.getMimeType();
    const isImage = (mime === "image/jpeg" || mime === "image/png" || mime === "image/webp");
    if (isImage) imageCount++; else nonImageCount++;
  }

  SpreadsheetApp.getUi().alert(
    "処理フォルダ内の残り件数\n\n" +
    "合計: " + total + " 件\n" +
    "画像: " + imageCount + " 件\n" +
    "画像以外: " + nonImageCount + " 件"
  );
}

function menu_openFailLog() {
  const ssJaId = PropertiesService.getScriptProperties().getProperty("ACTIVE_SS_JA_ID");
  if (!ssJaId) {
    SpreadsheetApp.getUi().alert("まだ出力スプレッドシートが作成されていません。先に一度実行してください。");
    return;
  }
  const ss = SpreadsheetApp.openById(ssJaId);
  const sh = ss.getSheetByName("fail_log");
  if (!sh) {
    SpreadsheetApp.getUi().alert("失敗ログはまだありません（fail_logシートが存在しません）。");
    return;
  }
  ss.setActiveSheet(sh);
  SpreadsheetApp.getUi().alert("fail_log シートを開きました。");
}

function menu_clearRunState() {
  clearRunState_();
  SpreadsheetApp.getUi().alert("実行状態（RunState）をリセットしました。次回実行で新しい出力シートが作成されます。");
}

/***** MAIN (callable without UI) *****/
// 互換のため残しておく（手動実行/トリガー用）
function runPipeline() {
  runPipelineWithSummary_();
}

/***** MAIN with UI summary + fail log *****/
function runPipelineWithSummary_() {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    const apiKey = PropertiesService.getScriptProperties().getProperty("OPENAI_API_KEY");
    if (!apiKey) throw new Error("OPENAI_API_KEY is not set in Script Properties.");

    const startMs = Date.now();

    const root = DriveApp.getFolderById(ROOT_FOLDER_ID);
    const processFolder = getOrCreateChildFolder_(root, PROCESS_FOLDER_NAME);
    const doneFolder = getOrCreateChildFolder_(root, DONE_FOLDER_NAME);
    const errorFolder = getOrCreateChildFolder_(root, ERROR_FOLDER_NAME);

    // RunState: keep same output sheets across multiple runs
    const runState = getOrCreateRunState_(root);

    const ssJa = SpreadsheetApp.openById(runState.ssJaId);
    const shJa = ssJa.getSheetByName("output_ja") || ssJa.getSheets()[0];

    const ssEn = SpreadsheetApp.openById(runState.ssEnId);
    const shEn = ssEn.getSheetByName("output_en") || ssEn.getSheets()[0];

    let processed = 0;
    let failed = 0;

    // batch write to reduce execution time
    const rowsJa = [];
    const rowsEn = [];

    const files = processFolder.getFiles();
    while (files.hasNext()) {
      if (Date.now() - startMs > SAFE_STOP_MS) break;
      if (processed >= MAX_PER_RUN) break;

      const file = files.next();
      const mime = file.getMimeType();
      if (!["image/jpeg", "image/png", "image/webp"].includes(mime)) continue;

      try {
        const imageDataUrl = makeDataUrl_(file.getBlob(), mime);

        if (Date.now() - startMs > SAFE_STOP_MS) break;

        const meta = generateMetadataStrict_(apiKey, imageDataUrl);

        if (Date.now() - startMs > SAFE_STOP_MS) break;

        const fixed = enforceRulesInGas_(apiKey, imageDataUrl, meta);

        rowsJa.push(buildRowJa_(file, fixed));
        rowsEn.push(buildRowEn_(file, fixed));

        // move processed file
        doneFolder.addFile(file);
        processFolder.removeFile(file);

        processed++;

      } catch (e) {
        failed++;
        try {
          const titleInfo = (typeof meta !== "undefined" && meta?.title_ja)
            ? " | TITLE=" + meta.title_ja
            : "";
          logFailure_(ssJa.getId(), file.getName(), e + titleInfo);
        } catch (_) {}

        try {
          errorFolder.addFile(file);
          processFolder.removeFile(file);
        } catch (_) {}

        console.error("[FAIL] " + file.getName() + ": " + e);
      }
    }

    // write accumulated rows
    if (rowsJa.length > 0) {
      const startRowJa = shJa.getLastRow() + 1;
      shJa.getRange(startRowJa, 1, rowsJa.length, buildHeaderJa_().length).setValues(rowsJa);
    }
    if (rowsEn.length > 0) {
      const startRowEn = shEn.getLastRow() + 1;
      shEn.getRange(startRowEn, 1, rowsEn.length, buildHeaderEn_().length).setValues(rowsEn);
    }

    // if no more files, clear run state
    if (!processFolder.getFiles().hasNext()) {
      clearRunState_();
    }

    const sec = Math.round((Date.now() - startMs) / 1000);
    const summary = `完了：${processed} 件 / 失敗：${failed} 件（所要 ${sec} 秒）`;

    console.log(summary);
    return summary;

  } finally {
    lock.releaseLock();
  }
}

/***** RUN STATE (resume) *****/
function getOrCreateRunState_(rootFolder) {
  const props = PropertiesService.getScriptProperties();
  const existingJa = props.getProperty("ACTIVE_SS_JA_ID");
  const existingEn = props.getProperty("ACTIVE_SS_EN_ID");

  if (existingJa && existingEn) {
    return { ssJaId: existingJa, ssEnId: existingEn };
  }

  const stamp = Utilities.formatDate(new Date(), "Asia/Tokyo", "yyyyMMdd_HHmm");

  const ssJa = SpreadsheetApp.create("titles_tags_JA_" + stamp);
  const shJa = ssJa.getSheets()[0];
  shJa.setName("output_ja");
  shJa.getRange(1, 1, 1, buildHeaderJa_().length).setValues([buildHeaderJa_()]);

  const ssEn = SpreadsheetApp.create("titles_tags_EN_" + stamp);
  const shEn = ssEn.getSheets()[0];
  shEn.setName("output_en");
  shEn.getRange(1, 1, 1, buildHeaderEn_().length).setValues([buildHeaderEn_()]);

  // move to ROOT so sheets survive even if later timeout happens
  DriveApp.getFileById(ssJa.getId()).moveTo(rootFolder);
  DriveApp.getFileById(ssEn.getId()).moveTo(rootFolder);

  props.setProperty("ACTIVE_SS_JA_ID", ssJa.getId());
  props.setProperty("ACTIVE_SS_EN_ID", ssEn.getId());

  return { ssJaId: ssJa.getId(), ssEnId: ssEn.getId() };
}

function clearRunState_() {
  const props = PropertiesService.getScriptProperties();
  props.deleteProperty("ACTIVE_SS_JA_ID");
  props.deleteProperty("ACTIVE_SS_EN_ID");
}

/***** FAIL LOG *****/
function logFailure_(ssJaId, filename, err) {
  const ss = SpreadsheetApp.openById(ssJaId);
  const sh = ss.getSheetByName("fail_log") || ss.insertSheet("fail_log");
  if (sh.getLastRow() === 0) sh.appendRow(["Time", "Filename", "Error"]);

  const msg = (err && err.stack) ? err.stack : String(err);
  sh.appendRow([new Date(), filename, msg.slice(0, 1000)]);
}

/***** OPENAI (Structured Outputs via Responses API) *****/
function generateMetadataStrict_(apiKey, imageDataUrl) {
  const system = [
    "You create stock photo metadata.",
    "Output must strictly match the JSON schema.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (a name-like caption), not a full sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use phrases like '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Do NOT use evaluative/emotional words (e.g., 美しい, 感動, 仕上げた).",
    "- Do NOT use the word '風景' in the Japanese title.",
    
  "- Also output title_ja_candidates: 5 alternatives.",
  "- The 5 candidates must differ in wording/order; avoid templates.",
  "- Avoid overused phrases: 青空の下, 背景, 景観, 光景, 眺め, 一面, 広がる, 見える, 染まる.",
  "- Verbs are allowed inside, but do NOT end with a verb (keep noun-phrase ending).",
"",
    "[Tags rules]",
    "- Japanese tags: exactly 49 items, no duplicates.",
    "- Japanese tags must be Japanese-only. Do NOT include any English letters (A-Z/a-z).",
    "- English title: at least 5 words.",
    "- English tags: exactly 49 items, no duplicates.",
    "- Avoid overusing the word 日本 (prefer 0, max 1)."
  ].join("\n");

  const schema = {
    name: "photo_metadata",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 1 },
        title_ja_candidates: { type: "array", minItems: JP_TITLE_CANDIDATES, maxItems: JP_TITLE_CANDIDATES, items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" } },
tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" } // ✅ no English letters
        },
        title_en: { type: "string", minLength: 1 },
        tags_en: { type: "array", minItems: 49, maxItems: 49, items: { type: "string", minLength: 1 } }
      },
      required: ["title_ja", "title_ja_candidates", "tags_ja", "title_en", "tags_en"]
    }
  };

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Generate title and tags for this image per the schema." },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  const res = callOpenAI_(apiKey, payload);
  const jsonText = extractOutputText_(res);
  if (!jsonText) {
    console.error("Empty output. Raw response (truncated): " + JSON.stringify(res).slice(0, 2000));
    throw new Error("Model output is empty.");
  }
  return safeJsonParse_(jsonText);
}

function enforceRulesInGas_(apiKey, imageDataUrl, meta) {
  meta.title_ja = String(meta.title_ja || "").trim();
  
  // ===== pick best JP title from candidates (anti-bias) =====
  const history = getTitleHistoryFromProps_();
  if (Array.isArray(meta.title_ja_candidates) && meta.title_ja_candidates.length) {
    const picked = pickBestJapaneseTitle_(meta.title_ja_candidates, history);
    if (picked) meta.title_ja = picked;
  }
  meta.title_ja = String(meta.title_ja || "").trim();

meta.title_en = String(meta.title_en || "").trim();

  meta.tags_ja = uniq_(meta.tags_ja);
  meta.tags_en = uniq_(meta.tags_en);

  // hard sanitize tags_ja
  meta.tags_ja = sanitizeJapaneseTags_(meta.tags_ja);

  // checks
  const needsJaLenFix = meta.title_ja.length < 15 || meta.title_ja.length > 30;
  const needsJaBannedFix = containsBannedWord_(meta.title_ja, JP_TITLE_BANNED_WORDS);
  const needsJaSentenceFix = isSentenceLikeJapaneseTitle_(meta.title_ja);
  const needsJaNoFukeiPatternFix = /の風景$/.test(meta.title_ja); // extra guard

  const hasEnglishInJaTags = meta.tags_ja.some(t => EN_LETTER_RE.test(String(t || "")));
  const needsJaTagsFix = hasEnglishInJaTags || (meta.tags_ja.length !== 49);

  const enWords = meta.title_en.split(/\s+/).filter(Boolean).length;
  const needsEnTitleFix = enWords < 5;

  const needsEnTagsFix = meta.tags_en.length !== 49;

  const needsJaTitleFix = needsJaLenFix || needsJaBannedFix || needsJaSentenceFix || needsJaNoFukeiPatternFix;

  if (!needsJaTitleFix && !needsJaTagsFix && !needsEnTitleFix && !needsEnTagsFix) {
    meta.tags_ja = meta.tags_ja.slice(0, 49);
    meta.tags_en = meta.tags_en.slice(0, 49);
    pushTitleHistoryToProps_(meta.title_ja);
    return meta;
  }

  // Fix prompt
  const system = [
    "You are a stock photo metadata editor.",
    "Fix the given JSON to satisfy constraints.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (name-like caption), not a sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use phrases like '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Do NOT use evaluative/emotional words like 美しい/感動/仕上げた etc.",
    "- Do NOT use the word '風景' and avoid the pattern '〜の風景'.",
    "",
    "[Japanese tags rules]",
    "- Exactly 49 items, Japanese-only, no duplicates.",
    "- NEVER include English letters A-Z/a-z in Japanese tags.",
    "",
    "[English rules]",
    "- English title must be at least 5 words.",
    "- English tags: exactly 49, no duplicates.",
    "",
    "Avoid overusing 日本 (prefer 0, max 1).",
    "Also output title_ja_candidates: 5 alternatives (same constraints).",
  "Output must strictly match the schema JSON only."
  ].join("\n");

  const schema = {
    name: "photo_metadata",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 1 },
        title_ja_candidates: { type: "array", minItems: JP_TITLE_CANDIDATES, maxItems: JP_TITLE_CANDIDATES, items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" } },
        tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" }
        },
        title_en: { type: "string", minLength: 1 },
        tags_en: { type: "array", minItems: 49, maxItems: 49, items: { type: "string", minLength: 1 } }
      },
      required: ["title_ja", "title_ja_candidates", "tags_ja", "title_en", "tags_en"]
    }
  };

  const issues = [];
  if (needsJaLenFix) issues.push("JP title length must be 15-30.");
  if (needsJaBannedFix) issues.push("JP title contains banned subjective/generic words.");
  if (needsJaSentenceFix) issues.push("JP title must be noun phrase; no です/ます and no verb endings.");
  if (needsJaNoFukeiPatternFix) issues.push("Avoid '〜の風景'.");
  if (needsJaTagsFix) issues.push("JP tags must be 49 and Japanese-only (no English letters).");
  if (needsEnTitleFix) issues.push("EN title must be >= 5 words.");
  if (needsEnTagsFix) issues.push("EN tags must be exactly 49.");

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Fix this JSON.\nIssues:\n- " + issues.join("\n- ") + "\n\nJSON:\n" + JSON.stringify(meta) },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  const res = callOpenAI_(apiKey, payload);
  const fixedText = extractOutputText_(res);
  if (!fixedText) {
    console.error("Empty output (fix). Raw response (truncated): " + JSON.stringify(res).slice(0, 2000));
    throw new Error("Model output is empty (fix).");
  }

  const out = safeJsonParse_(fixedText);

  // final sanitize
  out.title_ja = String(out.title_ja || "").trim();
  out.title_en = String(out.title_en || "").trim();
  out.tags_ja = sanitizeJapaneseTags_(uniq_(out.tags_ja)).slice(0, 49);
  out.tags_en = uniq_(out.tags_en).slice(0, 49);

  
  // ===== pick best JP title from candidates again (after fix) =====
  const history2 = getTitleHistoryFromProps_();
  if (Array.isArray(out.title_ja_candidates) && out.title_ja_candidates.length) {
    const picked2 = pickBestJapaneseTitle_(out.title_ja_candidates, history2);
    if (picked2) out.title_ja = picked2;
  }
  out.title_ja = String(out.title_ja || "").trim();

  // If still violated, do targeted JP repair
  const stillBad =
    out.title_ja.length < 15 || out.title_ja.length > 30 ||
    containsBannedWord_(out.title_ja, JP_TITLE_BANNED_WORDS) ||
    isSentenceLikeJapaneseTitle_(out.title_ja) ||
    /風景/.test(out.title_ja) ||
    /の風景$/.test(out.title_ja) ||
    out.tags_ja.length !== 49;

  if (stillBad) {
    return repairJaOnly_(apiKey, imageDataUrl, out);
  }

  pushTitleHistoryToProps_(out.title_ja);
  return out;
}

// Targeted repair: JP title & JP tags only
function repairJaOnly_(apiKey, imageDataUrl, meta) {
  const system = [
    "You fix ONLY Japanese title and Japanese tags.",
    "Return JSON matching schema. Keep English fields unchanged.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (name-like caption), not a sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Avoid evaluative/emotional words (美しい/感動/仕上げた etc.).",
    "- Do NOT use the word '風景' and avoid '〜の風景'.",
    "",
    "[Japanese tags rules]",
    "- Exactly 49 items, Japanese-only, no duplicates.",
    "- NEVER include English letters A-Z/a-z in Japanese tags."
  ].join("\n");

  const schema = {
    name: "photo_metadata_ja_only",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 15, maxLength: 30 },
        tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" }
        }
      },
      required: ["title_ja", "tags_ja"]
    }
  };

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Update JP fields for this image. Current meta (EN keep same):\n" + JSON.stringify(meta) },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  // ===== retry repair for JP tags (because sanitize/uniq can drop items) =====
  const MAX_REPAIR_TRIES = 3; // 1回目 + 再試行1回（必要なら3にしてOK）
  let lastCount = 0;
  let lastErr = null;

  for (let i = 0; i < MAX_REPAIR_TRIES; i++) {
    try {
      // 2回目以降は「49個に必ず埋める」指示を強める
      const extraInstr = (i === 0) ? "" : [
        "",
        "【再修正】前回はタグが49個に満たなかった。",
        "- 重複・英字・記号を避け、必ず49個の日本語タグに埋めること。",
        "- 各タグは短い名詞（単語）にすること。",
        "- 似た語でもよいので不足分を補完して49個にすること。"
      ].join("\n");

      // payload を「このループ内で」作り直す（extraInstr を user text に追記）
      const payload2 = JSON.parse(JSON.stringify(payload));
      // user の input_text を探して末尾に追記（構造はあなたの既存payloadに合わせた安全なやり方）
      const user = payload2.input.find(x => x.role === "user");
      const t = user.content.find(c => c.type === "input_text");
      t.text = t.text + extraInstr;

      const res = callOpenAI_(apiKey, payload2);
      const txt = extractOutputText_(res);
      if (!txt) throw new Error("Model output is empty (repairJaOnly).");

      const ja = safeJsonParse_(txt);

      // title は普通に採用
      meta.title_ja = String(ja.title_ja || "").trim();

      // tags は「浄化→重複除去」した結果で厳密に49を狙う
      let tags = uniq_(sanitizeJapaneseTags_(ja.tags_ja));
      lastCount = tags.length;

      if (tags.length === 49) {
        meta.tags_ja = tags;
        lastErr = null;
        break; // 成功
      }

      // 49に満たない場合：次ループで強指示して再生成
      lastErr = new Error("JP tags count is not 49 after repair. got=" + tags.length);

    } catch (e) {
      lastErr = e;
    }
  }

  // 最終的に49未満でも、ローカル補完で必ず49にする（運用停止を防ぐ）
  if (!meta.tags_ja || meta.tags_ja.length !== 49) {
    // 最後に取得できた候補があるならそれを使う（無ければ既存meta.tags_ja）
    const base = meta.tags_ja || [];
    meta.tags_ja = fillTo49JapaneseTags_(base);
  }

  // 念のため最終チェック
  if (meta.tags_ja.length !== 49) {
    throw lastErr || new Error("JP tags count is not 49 after repair. got=" + meta.tags_ja.length);
  }

  if (containsBannedWord_(meta.title_ja, JP_TITLE_BANNED_WORDS)) {
    Logger.log("NG TITLE AFTER REPAIR: " + meta.title_ja);
    throw new Error("JP title contains banned words after repair.");
  }
  if (isSentenceLikeJapaneseTitle_(meta.title_ja)) throw new Error("JP title still looks like a sentence after repair.");
  if (/風景/.test(meta.title_ja) || /の風景$/.test(meta.title_ja)) throw new Error("JP title still contains 風景 after repair.");

  pushTitleHistoryToProps_(meta.title_ja);
  return meta;
}

/***** OPENAI low-level *****/
function callOpenAI_(apiKey, payload) {
  const url = "https://api.openai.com/v1/responses";

  const headers = {
    Authorization: "Bearer " + apiKey,
  };

  const MAX_TRIES = 4;        // リトライ込み
  const BASE_SLEEP_MS = 800;

  let lastText = "";
  for (let i = 0; i < MAX_TRIES; i++) {
    const res = UrlFetchApp.fetch(url, {
      method: "post",
      contentType: "application/json",
      headers,
      payload: JSON.stringify(payload),
      muteHttpExceptions: true,
    });

    const code = res.getResponseCode();
    const text = res.getContentText();
    lastText = text;

    if (code >= 200 && code < 300) {
      // ここは「OpenAIレスポンス全体(JSON)」を返す想定（あなたの既存処理に合わせる）
      return JSON.parse(text);
    }

    // retry 判定（500系/429/model_errorは再試行）
    let errType = "";
    try {
      const j = JSON.parse(text);
      errType = j?.error?.type || "";
    } catch (_) {}

    const retryable =
      (code === 429) ||
      (code >= 500 && code <= 504) ||
      (errType === "model_error");

    if (!retryable || i === MAX_TRIES - 1) {
      throw new Error(`OpenAI error ${code}: ${text}`);
    }

    Utilities.sleep(BASE_SLEEP_MS * Math.pow(2, i) + Math.floor(Math.random() * 250));
  }

  throw new Error(`OpenAI error: ${lastText}`);
}

function extractOutputText_(res) {
  if (res && typeof res.output_text === "string" && res.output_text.trim()) return res.output_text.trim();

  const outputs = (res && res.output) ? res.output : [];
  for (const out of outputs) {
    const contents = out.content || [];
    for (const c of contents) {
      if (c && typeof c.text === "string" && c.text.trim()) return c.text.trim();
    }
  }
  return "";
}

/***** COLUMNS (your format) *****/
function buildHeaderJa_() {
  return ["Filename", "Title", "Keywords", "Category", "Releases"];
}
function buildHeaderEn_() {
  return ["Filename", "Description", "Keywords", "Categories", "Editorial", "Mature content", "illustration"];
}

function buildRowJa_(file, meta) {
  return [file.getName(), meta.title_ja, meta.tags_ja.join(","), "", ""];
}
function buildRowEn_(file, meta) {
  return [file.getName(), meta.title_en, meta.tags_en.join(","), "nature", "no", "yes", "no"];
}

/***** UTILS *****/
function getOrCreateChildFolder_(parent, name) {
  const it = parent.getFoldersByName(name);
  return it.hasNext() ? it.next() : parent.createFolder(name);
}

function safeJsonParse_(text) {
  const raw = String(text || "").trim();
  if (!raw) throw new Error("safeJsonParse_: empty text");

  // 1) code fence を除去
  let s = raw
    .replace(/^```(?:json)?\s*/i, "")
    .replace(/\s*```$/i, "")
    .trim();

  // 2) そのままJSONとして読めるなら読む
  try {
    return JSON.parse(s);
  } catch (_) {}

  // 3) 文字列中の「最初の { 」から「最後の } 」までを抜き出して再挑戦
  const first = s.indexOf("{");
  const last = s.lastIndexOf("}");
  if (first !== -1 && last !== -1 && last > first) {
    const sliced = s.slice(first, last + 1);
    try {
      return JSON.parse(sliced);
    } catch (e) {
      throw new Error("safeJsonParse_: invalid JSON after slicing: " + e + "\nRAW(head): " + raw.slice(0, 300));
    }
  }

  throw new Error("safeJsonParse_: no JSON object found.\nRAW(head): " + raw.slice(0, 300));
}

function makeDataUrl_(blob, mime) {
  const b64 = Utilities.base64Encode(blob.getBytes());
  return "data:" + mime + ";base64," + b64;
}

function uniq_(arr) {
  const seen = new Set();
  const out = [];
  (arr || []).forEach(s => {
    const v = String(s || "").trim();
    if (!v || seen.has(v)) return;
    seen.add(v);
    out.push(v);
  });
  return out;
}

function containsBannedWord_(text, bannedList) {
  const t = String(text || "");
  return (bannedList || []).some(w => w && t.indexOf(w) !== -1);
}

// ✅ JP tags: remove English letters + junk keys + empty
function sanitizeJapaneseTags_(tags) {
  const out = [];
  for (const t of (tags || [])) {
    const s = String(t || "").trim();
    if (!s) continue;
    if (EN_LETTER_RE.test(s)) continue;
    if (isJunkTag_(s)) continue;
    out.push(s);
  }
  return out;
}

function isJunkTag_(tag) {
  const t = String(tag || "").trim();
  if (!t) return true;
  const lowered = t.toLowerCase();
  if (lowered === "title_en" || lowered === "tags_en" || lowered === "title_ja" || lowered === "tags_ja") return true;
  return false;
}

// ✅ JP title: block sentence-like endings and common “caption sentence” patterns
function isSentenceLikeJapaneseTitle_(title) {
  const t = String(title || "").trim();

  // polite/statement endings (sentence)
  if (/(です|ます|でした|ました|である|だ)$/.test(t)) return true;

  // “〜の写真です” style
  if (/(写真|画像)(です|である)$/.test(t)) return true;

  // punctuation ending suggests sentence
  if (/[。\.]$/.test(t)) return true;

  // verb-ish endings (we want noun phrase)
  if (/(している|していた|しているところ|している様子)$/.test(t)) return true;
  if (/(見ている|眺める|歩く|走る|座る|立つ|撮影した|捉えた|映す|映した|表現した|描いた)$/.test(t)) return true;

  // generic filler pattern
  if (/の風景$/.test(t)) return true;

  return false;
}

function fillTo49JapaneseTags_(tags) {
  let out = uniq_(sanitizeJapaneseTags_(tags));
  const used = new Set(out);

  for (const cand of JP_FALLBACK_TAG_POOL) {
    if (out.length >= 49) break;
    const t = String(cand || "").trim();
    if (!t) continue;
    if (EN_LETTER_RE.test(t)) continue;
    if (used.has(t)) continue;
    out.push(t);
    used.add(t);
  }
  return out.slice(0, 49);
}

/***** JP Title anti-bias utils (add) *****/

// ※ CONFIGに以下が無い場合は追加してください（既にあるなら不要）
// const TITLE_HISTORY_KEY = "TITLE_HISTORY_JP";
// const TITLE_HISTORY_MAX = 120;
// const TITLE_SIM_THRESHOLD = 0.55;
// const JP_TITLE_OVERUSED_PHRASES = ["青空の下","背景","景観","光景","眺め","一面","広がる","見える","染まる"];

function getTitleHistoryFromProps_() {
  const props = PropertiesService.getScriptProperties();
  const raw = props.getProperty(TITLE_HISTORY_KEY) || "[]";
  try {
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  } catch (e) {
    return [];
  }
}

function pushTitleHistoryToProps_(title) {
  const t = String(title || "").trim();
  if (!t) return;

  const props = PropertiesService.getScriptProperties();
  const arr = getTitleHistoryFromProps_();
  arr.unshift(t);
  while (arr.length > TITLE_HISTORY_MAX) arr.pop();
  props.setProperty(TITLE_HISTORY_KEY, JSON.stringify(arr));
}

function ngrams_(s, n) {
  const t = String(s || "").trim();
  const out = new Set();
  if (t.length < n) return out;
  for (let i = 0; i <= t.length - n; i++) out.add(t.slice(i, i + n));
  return out;
}

function jaccard_(aSet, bSet) {
  if (!aSet.size || !bSet.size) return 0;
  let inter = 0;
  for (const x of aSet) if (bSet.has(x)) inter++;
  const union = aSet.size + bSet.size - inter;
  return union ? inter / union : 0;
}

function maxSimilarityToHistory_(title, history) {
  const a = ngrams_(title, 3); // 3-gram
  let max = 0;
  for (const h of (history || [])) {
    const sim = jaccard_(a, ngrams_(h, 3));
    if (sim > max) max = sim;
  }
  return max;
}

function scoreJapaneseTitleCandidate_(title, history) {
  const t = String(title || "").trim();
  if (!t) return -9999;

  // ✅ 既存思想：ルール違反は即死
  if (t.length < 15 || t.length > 30) return -9999;
  if (EN_LETTER_RE.test(t)) return -9999;
  if (containsBannedWord_(t, JP_TITLE_BANNED_WORDS)) return -9999;
  if (isSentenceLikeJapaneseTitle_(t)) return -9999;
  if (/の風景$/.test(t) || /風景/.test(t)) return -9999;

  let score = 1000;

  // 定型句は“弱”減点（禁止しない）
  for (const p of (JP_TITLE_OVERUSED_PHRASES || [])) {
    if (t.includes(p)) score -= 40;
  }

  // 「と」の羅列抑制
  const andCount = (t.match(/と/g) || []).length;
  if (andCount >= 3) score -= 60;

  // 直近履歴との類似度ペナルティ
  const sim = maxSimilarityToHistory_(t, history);
  score -= (sim >= TITLE_SIM_THRESHOLD) ? Math.round(600 * sim) : Math.round(200 * sim);

  return score;
}

function pickBestJapaneseTitle_(candidates, history) {
  let best = "";
  let bestScore = -9999;

  for (const c of (candidates || [])) {
    const sc = scoreJapaneseTitleCandidate_(c, history);
    if (sc > bestScore) {
      bestScore = sc;
      best = String(c || "").trim();
    }
  }
  return best;
}
