/***** CONFIG *****/
const ROOT_FOLDER_ID = "1F_Byvx8MzyhFDqcZxbD4pyqunw4oy7nn";
const PROCESS_FOLDER_NAME = "処理";
const DONE_FOLDER_NAME = "完了";
const ERROR_FOLDER_NAME = "失敗"; // optional

// ✅ precision priority
const OPENAI_MODEL = "gpt-4o";

// Safety controls
const MAX_PER_RUN = 10;          // process up to N images per execution
const SAFE_STOP_MS = 320000;     // stop around 5m20s (6min limit margin)

// Japanese title ban list（主観/感情/演出＋冗長語）
const JP_TITLE_BANNED_WORDS = [
  "美しい","綺麗","きれい","感動","感動的","仕上げた","仕上がり","素敵","魅力","エモい","かわいい","可愛い",
  "最高","最適","印象的","ドラマチック","幻想的","優雅","エレガント","ロマンチック","おしゃれ","オシャレ",
  "心","気持ち","癒し","映える","映し出す","楽しむ","感じる",
  "風景" // ✅ avoid generic filler
];

const EN_LETTER_RE = /[A-Za-z]/;

/***** SPREADSHEET MENU *****/
function onOpen(e) {
  SpreadsheetApp.getUi()
    .createMenu("画像処理")
    .addItem("処理を実行（タイトル＆タグ生成）", "menu_runPipeline")
    .addSeparator()
    .addItem("処理フォルダの残り枚数を表示", "menu_showRemainingCount")
    .addItem("失敗ログを開く", "menu_openFailLog")
    .addSeparator()
    .addItem("実行状態をリセット（RunState削除）", "menu_clearRunState")
    .addToUi();
}

function menu_runPipeline() {
  const ui = SpreadsheetApp.getUi();
  try {
    const summary = runPipelineWithSummary_();
    SpreadsheetApp.getActive().toast(summary, "画像処理", 8);
    ui.alert(summary);
  } catch (e) {
    const msg = "実行中にエラーが発生しました。\n\n" + String(e);
    SpreadsheetApp.getActive().toast(msg, "画像処理（エラー）", 10);
    ui.alert(msg);
    throw e; // Executionsにも残す
  }
}

function menu_showRemainingCount() {
  const root = DriveApp.getFolderById(ROOT_FOLDER_ID);
  const processFolder = getOrCreateChildFolder_(root, PROCESS_FOLDER_NAME);

  let total = 0, imageCount = 0, nonImageCount = 0;
  const files = processFolder.getFiles();
  while (files.hasNext()) {
    const f = files.next();
    total++;
    const mime = f.getMimeType();
    const isImage = (mime === "image/jpeg" || mime === "image/png" || mime === "image/webp");
    if (isImage) imageCount++; else nonImageCount++;
  }

  SpreadsheetApp.getUi().alert(
    "処理フォルダ内の残り件数\n\n" +
    "合計: " + total + " 件\n" +
    "画像: " + imageCount + " 件\n" +
    "画像以外: " + nonImageCount + " 件"
  );
}

function menu_openFailLog() {
  const ssJaId = PropertiesService.getScriptProperties().getProperty("ACTIVE_SS_JA_ID");
  if (!ssJaId) {
    SpreadsheetApp.getUi().alert("まだ出力スプレッドシートが作成されていません。先に一度実行してください。");
    return;
  }
  const ss = SpreadsheetApp.openById(ssJaId);
  const sh = ss.getSheetByName("fail_log");
  if (!sh) {
    SpreadsheetApp.getUi().alert("失敗ログはまだありません（fail_logシートが存在しません）。");
    return;
  }
  ss.setActiveSheet(sh);
  SpreadsheetApp.getUi().alert("fail_log シートを開きました。");
}

function menu_clearRunState() {
  clearRunState_();
  SpreadsheetApp.getUi().alert("実行状態（RunState）をリセットしました。次回実行で新しい出力シートが作成されます。");
}

/***** MAIN (callable without UI) *****/
// 互換のため残しておく（手動実行/トリガー用）
function runPipeline() {
  runPipelineWithSummary_();
}

/***** MAIN with UI summary + fail log *****/
function runPipelineWithSummary_() {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    const apiKey = PropertiesService.getScriptProperties().getProperty("OPENAI_API_KEY");
    if (!apiKey) throw new Error("OPENAI_API_KEY is not set in Script Properties.");

    const startMs = Date.now();

    const root = DriveApp.getFolderById(ROOT_FOLDER_ID);
    const processFolder = getOrCreateChildFolder_(root, PROCESS_FOLDER_NAME);
    const doneFolder = getOrCreateChildFolder_(root, DONE_FOLDER_NAME);
    const errorFolder = getOrCreateChildFolder_(root, ERROR_FOLDER_NAME);

    // RunState: keep same output sheets across multiple runs
    const runState = getOrCreateRunState_(root);

    const ssJa = SpreadsheetApp.openById(runState.ssJaId);
    const shJa = ssJa.getSheetByName("output_ja") || ssJa.getSheets()[0];

    const ssEn = SpreadsheetApp.openById(runState.ssEnId);
    const shEn = ssEn.getSheetByName("output_en") || ssEn.getSheets()[0];

    let processed = 0;
    let failed = 0;

    // batch write to reduce execution time
    const rowsJa = [];
    const rowsEn = [];

    const files = processFolder.getFiles();
    while (files.hasNext()) {
      if (Date.now() - startMs > SAFE_STOP_MS) break;
      if (processed >= MAX_PER_RUN) break;

      const file = files.next();
      const mime = file.getMimeType();
      if (!["image/jpeg", "image/png", "image/webp"].includes(mime)) continue;

      try {
        const imageDataUrl = makeDataUrl_(file.getBlob(), mime);

        const meta = generateMetadataStrict_(apiKey, imageDataUrl);
        const fixed = enforceRulesInGas_(apiKey, imageDataUrl, meta);

        rowsJa.push(buildRowJa_(file, fixed));
        rowsEn.push(buildRowEn_(file, fixed));

        // move processed file
        doneFolder.addFile(file);
        processFolder.removeFile(file);

        processed++;

      } catch (e) {
        failed++;
        try { logFailure_(ssJa.getId(), file.getName(), e); } catch (_) {}

        try {
          errorFolder.addFile(file);
          processFolder.removeFile(file);
        } catch (_) {}

        console.error("[FAIL] " + file.getName() + ": " + e);
      }
    }

    // write accumulated rows
    if (rowsJa.length > 0) {
      const startRowJa = shJa.getLastRow() + 1;
      shJa.getRange(startRowJa, 1, rowsJa.length, buildHeaderJa_().length).setValues(rowsJa);
    }
    if (rowsEn.length > 0) {
      const startRowEn = shEn.getLastRow() + 1;
      shEn.getRange(startRowEn, 1, rowsEn.length, buildHeaderEn_().length).setValues(rowsEn);
    }

    // if no more files, clear run state
    if (!processFolder.getFiles().hasNext()) {
      clearRunState_();
    }

    const sec = Math.round((Date.now() - startMs) / 1000);
    const summary = `完了：${processed} 件 / 失敗：${failed} 件（所要 ${sec} 秒）`;

    console.log(summary);
    return summary;

  } finally {
    lock.releaseLock();
  }
}

/***** RUN STATE (resume) *****/
function getOrCreateRunState_(rootFolder) {
  const props = PropertiesService.getScriptProperties();
  const existingJa = props.getProperty("ACTIVE_SS_JA_ID");
  const existingEn = props.getProperty("ACTIVE_SS_EN_ID");

  if (existingJa && existingEn) {
    return { ssJaId: existingJa, ssEnId: existingEn };
  }

  const stamp = Utilities.formatDate(new Date(), "Asia/Tokyo", "yyyyMMdd_HHmm");

  const ssJa = SpreadsheetApp.create("titles_tags_JA_" + stamp);
  const shJa = ssJa.getSheets()[0];
  shJa.setName("output_ja");
  shJa.getRange(1, 1, 1, buildHeaderJa_().length).setValues([buildHeaderJa_()]);

  const ssEn = SpreadsheetApp.create("titles_tags_EN_" + stamp);
  const shEn = ssEn.getSheets()[0];
  shEn.setName("output_en");
  shEn.getRange(1, 1, 1, buildHeaderEn_().length).setValues([buildHeaderEn_()]);

  // move to ROOT so sheets survive even if later timeout happens
  DriveApp.getFileById(ssJa.getId()).moveTo(rootFolder);
  DriveApp.getFileById(ssEn.getId()).moveTo(rootFolder);

  props.setProperty("ACTIVE_SS_JA_ID", ssJa.getId());
  props.setProperty("ACTIVE_SS_EN_ID", ssEn.getId());

  return { ssJaId: ssJa.getId(), ssEnId: ssEn.getId() };
}

function clearRunState_() {
  const props = PropertiesService.getScriptProperties();
  props.deleteProperty("ACTIVE_SS_JA_ID");
  props.deleteProperty("ACTIVE_SS_EN_ID");
}

/***** FAIL LOG *****/
function logFailure_(ssJaId, filename, err) {
  const ss = SpreadsheetApp.openById(ssJaId);
  const sh = ss.getSheetByName("fail_log") || ss.insertSheet("fail_log");
  if (sh.getLastRow() === 0) sh.appendRow(["Time", "Filename", "Error"]);

  const msg = (err && err.stack) ? err.stack : String(err);
  sh.appendRow([new Date(), filename, msg.slice(0, 1000)]);
}

/***** OPENAI (Structured Outputs via Responses API) *****/
function generateMetadataStrict_(apiKey, imageDataUrl) {
  const system = [
    "You create stock photo metadata.",
    "Output must strictly match the JSON schema.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (a name-like caption), not a full sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use phrases like '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Do NOT use evaluative/emotional words (e.g., 美しい, 感動, 仕上げた).",
    "- Do NOT use the word '風景' in the Japanese title.",
    "",
    "[Tags rules]",
    "- Japanese tags: exactly 49 items, no duplicates.",
    "- Japanese tags must be Japanese-only. Do NOT include any English letters (A-Z/a-z).",
    "- English title: at least 5 words.",
    "- English tags: exactly 49 items, no duplicates.",
    "- Avoid overusing the word 日本 (prefer 0, max 1)."
  ].join("\n");

  const schema = {
    name: "photo_metadata",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 1 },
        tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" } // ✅ no English letters
        },
        title_en: { type: "string", minLength: 1 },
        tags_en: { type: "array", minItems: 49, maxItems: 49, items: { type: "string", minLength: 1 } }
      },
      required: ["title_ja", "tags_ja", "title_en", "tags_en"]
    }
  };

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Generate title and tags for this image per the schema." },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  const res = callOpenAI_(apiKey, payload);
  const jsonText = extractOutputText_(res);
  if (!jsonText) {
    console.error("Empty output. Raw response (truncated): " + JSON.stringify(res).slice(0, 2000));
    throw new Error("Model output is empty.");
  }
  return safeJsonParse_(jsonText);
}

function enforceRulesInGas_(apiKey, imageDataUrl, meta) {
  meta.title_ja = String(meta.title_ja || "").trim();
  meta.title_en = String(meta.title_en || "").trim();

  meta.tags_ja = uniq_(meta.tags_ja);
  meta.tags_en = uniq_(meta.tags_en);

  // hard sanitize tags_ja
  meta.tags_ja = sanitizeJapaneseTags_(meta.tags_ja);

  // checks
  const needsJaLenFix = meta.title_ja.length < 15 || meta.title_ja.length > 30;
  const needsJaBannedFix = containsBannedWord_(meta.title_ja, JP_TITLE_BANNED_WORDS);
  const needsJaSentenceFix = isSentenceLikeJapaneseTitle_(meta.title_ja);
  const needsJaNoFukeiPatternFix = /の風景$/.test(meta.title_ja); // extra guard

  const hasEnglishInJaTags = meta.tags_ja.some(t => EN_LETTER_RE.test(String(t || "")));
  const needsJaTagsFix = hasEnglishInJaTags || (meta.tags_ja.length !== 49);

  const enWords = meta.title_en.split(/\s+/).filter(Boolean).length;
  const needsEnTitleFix = enWords < 5;

  const needsEnTagsFix = meta.tags_en.length !== 49;

  const needsJaTitleFix = needsJaLenFix || needsJaBannedFix || needsJaSentenceFix || needsJaNoFukeiPatternFix;

  if (!needsJaTitleFix && !needsJaTagsFix && !needsEnTitleFix && !needsEnTagsFix) {
    meta.tags_ja = meta.tags_ja.slice(0, 49);
    meta.tags_en = meta.tags_en.slice(0, 49);
    return meta;
  }

  // Fix prompt
  const system = [
    "You are a stock photo metadata editor.",
    "Fix the given JSON to satisfy constraints.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (name-like caption), not a sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use phrases like '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Do NOT use evaluative/emotional words like 美しい/感動/仕上げた etc.",
    "- Do NOT use the word '風景' and avoid the pattern '〜の風景'.",
    "",
    "[Japanese tags rules]",
    "- Exactly 49 items, Japanese-only, no duplicates.",
    "- NEVER include English letters A-Z/a-z in Japanese tags.",
    "",
    "[English rules]",
    "- English title must be at least 5 words.",
    "- English tags: exactly 49, no duplicates.",
    "",
    "Avoid overusing 日本 (prefer 0, max 1).",
    "Output must strictly match the schema JSON only."
  ].join("\n");

  const schema = {
    name: "photo_metadata",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 1 },
        tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" }
        },
        title_en: { type: "string", minLength: 1 },
        tags_en: { type: "array", minItems: 49, maxItems: 49, items: { type: "string", minLength: 1 } }
      },
      required: ["title_ja", "tags_ja", "title_en", "tags_en"]
    }
  };

  const issues = [];
  if (needsJaLenFix) issues.push("JP title length must be 15-30.");
  if (needsJaBannedFix) issues.push("JP title contains banned subjective/generic words.");
  if (needsJaSentenceFix) issues.push("JP title must be noun phrase; no です/ます and no verb endings.");
  if (needsJaNoFukeiPatternFix) issues.push("Avoid '〜の風景'.");
  if (needsJaTagsFix) issues.push("JP tags must be 49 and Japanese-only (no English letters).");
  if (needsEnTitleFix) issues.push("EN title must be >= 5 words.");
  if (needsEnTagsFix) issues.push("EN tags must be exactly 49.");

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Fix this JSON.\nIssues:\n- " + issues.join("\n- ") + "\n\nJSON:\n" + JSON.stringify(meta) },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  const res = callOpenAI_(apiKey, payload);
  const fixedText = extractOutputText_(res);
  if (!fixedText) {
    console.error("Empty output (fix). Raw response (truncated): " + JSON.stringify(res).slice(0, 2000));
    throw new Error("Model output is empty (fix).");
  }

  const out = safeJsonParse_(fixedText);

  // final sanitize
  out.title_ja = String(out.title_ja || "").trim();
  out.title_en = String(out.title_en || "").trim();
  out.tags_ja = sanitizeJapaneseTags_(uniq_(out.tags_ja)).slice(0, 49);
  out.tags_en = uniq_(out.tags_en).slice(0, 49);

  // If still violated, do targeted JP repair
  const stillBad =
    out.title_ja.length < 15 || out.title_ja.length > 30 ||
    containsBannedWord_(out.title_ja, JP_TITLE_BANNED_WORDS) ||
    isSentenceLikeJapaneseTitle_(out.title_ja) ||
    /風景/.test(out.title_ja) ||
    /の風景$/.test(out.title_ja) ||
    out.tags_ja.length !== 49;

  if (stillBad) {
    return repairJaOnly_(apiKey, imageDataUrl, out);
  }

  return out;
}

// Targeted repair: JP title & JP tags only
function repairJaOnly_(apiKey, imageDataUrl, meta) {
  const system = [
    "You fix ONLY Japanese title and Japanese tags.",
    "Return JSON matching schema. Keep English fields unchanged.",
    "",
    "[Japanese title rules]",
    "- 15-30 Japanese characters.",
    "- MUST be a noun phrase (name-like caption), not a sentence.",
    "- Do NOT end with です/ます/である/だ, and do NOT use '〜の写真です'.",
    "- Avoid verb endings such as している / 見ている / 撮影した / 捉えた / 映す.",
    "- Avoid evaluative/emotional words (美しい/感動/仕上げた etc.).",
    "- Do NOT use the word '風景' and avoid '〜の風景'.",
    "",
    "[Japanese tags rules]",
    "- Exactly 49 items, Japanese-only, no duplicates.",
    "- NEVER include English letters A-Z/a-z in Japanese tags."
  ].join("\n");

  const schema = {
    name: "photo_metadata_ja_only",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        title_ja: { type: "string", minLength: 15, maxLength: 30 },
        tags_ja: {
          type: "array",
          minItems: 49,
          maxItems: 49,
          items: { type: "string", minLength: 1, pattern: "^(?!.*[A-Za-z]).+$" }
        }
      },
      required: ["title_ja", "tags_ja"]
    }
  };

  const payload = {
    model: OPENAI_MODEL,
    input: [{
      role: "system",
      content: [{ type: "input_text", text: system }]
    },{
      role: "user",
      content: [
        { type: "input_text", text: "Update JP fields for this image. Current meta (EN keep same):\n" + JSON.stringify(meta) },
        { type: "input_image", image_url: imageDataUrl }
      ]
    }],
    text: { format: { type: "json_schema", ...schema } }
  };

  const res = callOpenAI_(apiKey, payload);
  const txt = extractOutputText_(res);
  if (!txt) throw new Error("Model output is empty (repairJaOnly).");

  const ja = safeJsonParse_(txt);

  meta.title_ja = String(ja.title_ja || "").trim();
  meta.tags_ja = sanitizeJapaneseTags_(uniq_(ja.tags_ja)).slice(0, 49);

  // strict final assertions
  if (meta.tags_ja.length !== 49) throw new Error("JP tags count is not 49 after repair.");
  if (containsBannedWord_(meta.title_ja, JP_TITLE_BANNED_WORDS)) throw new Error("JP title contains banned words after repair.");
  if (isSentenceLikeJapaneseTitle_(meta.title_ja)) throw new Error("JP title still looks like a sentence after repair.");
  if (/風景/.test(meta.title_ja) || /の風景$/.test(meta.title_ja)) throw new Error("JP title still contains 風景 after repair.");

  return meta;
}

/***** OPENAI low-level *****/
function callOpenAI_(apiKey, payload) {
  const url = "https://api.openai.com/v1/responses";
  const res = UrlFetchApp.fetch(url, {
    method: "post",
    contentType: "application/json",
    headers: { Authorization: "Bearer " + apiKey },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });

  const text = res.getContentText();
  if (res.getResponseCode() >= 400) throw new Error("OpenAI error " + res.getResponseCode() + ": " + text);
  return JSON.parse(text);
}

function extractOutputText_(res) {
  if (res && typeof res.output_text === "string" && res.output_text.trim()) return res.output_text.trim();

  const outputs = (res && res.output) ? res.output : [];
  for (const out of outputs) {
    const contents = out.content || [];
    for (const c of contents) {
      if (c && typeof c.text === "string" && c.text.trim()) return c.text.trim();
    }
  }
  return "";
}

/***** COLUMNS (your format) *****/
function buildHeaderJa_() {
  return ["Filename", "Title", "Keywords", "Category", "Releases"];
}
function buildHeaderEn_() {
  return ["Filename", "Description", "Keywords", "Categories", "Editorial", "Mature content", "illustration"];
}

function buildRowJa_(file, meta) {
  return [file.getName(), meta.title_ja, meta.tags_ja.join(","), "", ""];
}
function buildRowEn_(file, meta) {
  return [file.getName(), meta.title_en, meta.tags_en.join(","), "nature", "no", "yes", "no"];
}

/***** UTILS *****/
function getOrCreateChildFolder_(parent, name) {
  const it = parent.getFoldersByName(name);
  return it.hasNext() ? it.next() : parent.createFolder(name);
}

function safeJsonParse_(text) {
  const raw = String(text || "").trim();
  if (!raw) throw new Error("safeJsonParse_: empty text");

  // 1) code fence を除去
  let s = raw
    .replace(/^```(?:json)?\s*/i, "")
    .replace(/\s*```$/i, "")
    .trim();

  // 2) そのままJSONとして読めるなら読む
  try {
    return JSON.parse(s);
  } catch (_) {}

  // 3) 文字列中の「最初の { 」から「最後の } 」までを抜き出して再挑戦
  const first = s.indexOf("{");
  const last = s.lastIndexOf("}");
  if (first !== -1 && last !== -1 && last > first) {
    const sliced = s.slice(first, last + 1);
    try {
      return JSON.parse(sliced);
    } catch (e) {
      throw new Error("safeJsonParse_: invalid JSON after slicing: " + e + "\nRAW(head): " + raw.slice(0, 300));
    }
  }

  throw new Error("safeJsonParse_: no JSON object found.\nRAW(head): " + raw.slice(0, 300));
}

function makeDataUrl_(blob, mime) {
  const b64 = Utilities.base64Encode(blob.getBytes());
  return "data:" + mime + ";base64," + b64;
}

function uniq_(arr) {
  const seen = new Set();
  const out = [];
  (arr || []).forEach(s => {
    const v = String(s || "").trim();
    if (!v || seen.has(v)) return;
    seen.add(v);
    out.push(v);
  });
  return out;
}

function containsBannedWord_(text, bannedList) {
  const t = String(text || "");
  return (bannedList || []).some(w => w && t.indexOf(w) !== -1);
}

// ✅ JP tags: remove English letters + junk keys + empty
function sanitizeJapaneseTags_(tags) {
  const out = [];
  for (const t of (tags || [])) {
    const s = String(t || "").trim();
    if (!s) continue;
    if (EN_LETTER_RE.test(s)) continue;
    if (isJunkTag_(s)) continue;
    out.push(s);
  }
  return out;
}

function isJunkTag_(tag) {
  const t = String(tag || "").trim();
  if (!t) return true;
  const lowered = t.toLowerCase();
  if (lowered === "title_en" || lowered === "tags_en" || lowered === "title_ja" || lowered === "tags_ja") return true;
  return false;
}

// ✅ JP title: block sentence-like endings and common “caption sentence” patterns
function isSentenceLikeJapaneseTitle_(title) {
  const t = String(title || "").trim();

  // polite/statement endings (sentence)
  if (/(です|ます|でした|ました|である|だ)$/.test(t)) return true;

  // “〜の写真です” style
  if (/(写真|画像)(です|である)$/.test(t)) return true;

  // punctuation ending suggests sentence
  if (/[。\.]$/.test(t)) return true;

  // verb-ish endings (we want noun phrase)
  if (/(している|していた|しているところ|している様子)$/.test(t)) return true;
  if (/(見ている|眺める|歩く|走る|座る|立つ|撮影した|捉えた|映す|映した|表現した|描いた)$/.test(t)) return true;

  // generic filler pattern
  if (/の風景$/.test(t)) return true;

  return false;
}
